#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClient.h>
#include <SPI.h>
#include <MFRC522.h>
#include <ArduinoJson.h>
#include <PubSubClient.h>

// --- KONFIGURASI PENGGUNA (SESUAIKAN INI) ---
const char* WIFI_SSID = "UGM-Hotspot";
const char* WIFI_PASSWORD = "";

const char* SERVER_IP = "64.23.167.116"; 
const int MQTT_BROKER_PORT = 32357;
const int BACKEND_SERVER_PORT = 31435;

// --- KONFIGURASI TOPOLOGI & ID ---
const String RFID_AUTH_ENDPOINT = "/api/rfid/authenticate";
const char* MQTT_CLIENT_ID_BASE = "ESP8266_Controller_";
const char* TOPIC_BASE = "home/device"; // Base topic umum
const char* DOOR_DEVICE_ID = "pintu_utama"; // ID untuk status pintu

// --- KONFIGURASI PIN ---
#define SS_PIN D8    // Direkomendasikan: D8 untuk SS/SDA di NodeMCU
#define RST_PIN D3   // GPIO0
#define RELAY_DOOR_PIN D4 // Pin untuk relay pintu
#define BUZZER_PIN D2
// Logika Relay (ganti jika relay Anda active HIGH)
#define RELAY_ACTIVE_STATE LOW
#define RELAY_INACTIVE_STATE HIGH

// === DEFINISI PERANGKAT RELAY TAMBAHAN ===
const int NUM_RELAYS = 2; // Jumlah relay yang dikontrol via MQTT
struct RelayDevice {
  const char* deviceId;
  int pin;
  bool status;
  String topicControl;
};

RelayDevice relays[NUM_RELAYS] = {
  {"lampu_kamar_1", D1, false}, // Relay 1 (misalnya lampu_kamar_1 di pin D1)
  {"kipas_angin_1", D0, false}  // Relay 2 (misalnya kipas_angin_1 di pin D0)
};

// --- Inisialisasi Objek Global ---
MFRC522 mfrc522(SS_PIN, RST_PIN);
WiFiClient wifiHttp;
WiFiClient wifiMqtt;
PubSubClient mqttClient(wifiMqtt);
String mqttClientId;
const int doorOpenDuration = 5000; // Durasi pintu terbuka 5 detik
unsigned long lastMqttReconnectAttempt = 0;
unsigned long lastSelfTestTime = 0;
const long selfTestInterval = 30000; // Cek kesehatan modul RFID setiap 30 detik

// --- Deklarasi Fungsi (Prototypes) ---
void setup_wifi();
void reconnect_mqtt();
void bukaPintu();
void tolakAkses();
bool authenticateRfidViaApi(String uid);
void kirimLogScanMQTT(const char* uid, const char* status);
void setRelayState(int relayIndex, bool newState);
void publishDeviceStatus(const char* deviceId, bool newStatus);
void mqttCallback(char* topic, byte* payload, unsigned int length);

// --- FUNGSI SETUP ---
void setup() {
  Serial.begin(115200);
  while(!Serial);
  Serial.println("\nESP8266 Smarthome Controller - Inisialisasi...");

  // Setup Pins
  pinMode(RELAY_DOOR_PIN, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(RELAY_DOOR_PIN, RELAY_INACTIVE_STATE);
  for(int i = 0; i < NUM_RELAYS; i++) {
    pinMode(relays[i].pin, OUTPUT);
    digitalWrite(relays[i].pin, RELAY_INACTIVE_STATE);
    relays[i].status = false;
    relays[i].topicControl = String(TOPIC_BASE) + "/" + relays[i].deviceId + "/control";
  }

  // Generate unique MQTT ID & connect
  String mac = WiFi.macAddress(); mac.replace(":", "");
  mqttClientId = String(MQTT_CLIENT_ID_BASE) + mac;
  setup_wifi();
  mqttClient.setServer(SERVER_IP, MQTT_BROKER_PORT);
  mqttClient.setCallback(mqttCallback); // Penting untuk menerima pesan

  // Init SPI & MFRC522
  SPI.begin();
  mfrc522.PCD_Init();
  Serial.println("Tempelkan kartu RFID Anda...");
}

// --- FUNGSI CALLBACK UNTUK PESAN MQTT MASUK ---
void mqttCallback(char* topicChar, byte* payload, unsigned int length) {
  String topic = String(topicChar);
  String message = "";
  for (unsigned int i = 0; i < length; i++) { message += (char)payload[i]; }
  Serial.printf("MQTT Message Arrived: Topic [%s], Payload [%s]\n", topic.c_str(), message.c_str());

  // Cek apakah pesan ini untuk salah satu relay yang dikelola
  for (int i = 0; i < NUM_RELAYS; i++) {
    if (topic == relays[i].topicControl) {
      String action = "";
      StaticJsonDocument<64> doc;
      if (deserializeJson(doc, payload, length).code() == DeserializationError::Ok && doc.containsKey("action")) {
        action = String(doc["action"]);
      } else {
        action = message;
      }
      action.toUpperCase();

      Serial.printf("Action for %s: %s\n", relays[i].deviceId, action.c_str());
      if (action == "ON") {
        setRelayState(i, true);
      } else if (action == "OFF") {
        setRelayState(i, false);
      }
      return; 
    }
  }
}

void reconnect_mqtt() {
  if (WiFi.status() != WL_CONNECTED) return;
  unsigned long currentMillis = millis();
  if (!mqttClient.connected() && (currentMillis - lastMqttReconnectAttempt > 5000)) {
    lastMqttReconnectAttempt = currentMillis;
    Serial.print("Mencoba koneksi MQTT ke "); Serial.print(SERVER_IP); Serial.print("...");
    if (mqttClient.connect(mqttClientId.c_str())) {
      Serial.println("berhasil!");
      // Subscribe ke topik kontrol untuk semua relay
      for (int i = 0; i < NUM_RELAYS; i++) {
        mqttClient.subscribe(relays[i].topicControl.c_str());
        Serial.printf("MQTT: Subscribed to %s\n", relays[i].topicControl.c_str());
        publishDeviceStatus(relays[i].deviceId, relays[i].status);
      }
      publishDeviceStatus(DOOR_DEVICE_ID, false);
    } else {
      Serial.print("gagal, rc="); Serial.print(mqttClient.state());
      Serial.println(" coba lagi dalam 5 detik");
    }
  }
}

// --- FUNGSI PEMBANTU LAINNYA ---
void publishDeviceStatus(const char* deviceId, bool newStatus) {
  if (!mqttClient.connected()) return;
  String topic = String(TOPIC_BASE) + "/" + deviceId + "/status";
  const char* statusStr = newStatus ? "ON" : "OFF";
  Serial.printf("MQTT: Publishing to %s -> %s\n", topic.c_str(), statusStr);
  mqttClient.publish(topic.c_str(), statusStr, true); // Retained True
}

void setRelayState(int relayIndex, bool newState) {
  if (relayIndex < 0 || relayIndex >= NUM_RELAYS) return;
  if (relays[relayIndex].status != newState) {
    relays[relayIndex].status = newState;
    digitalWrite(relays[relayIndex].pin, relays[relayIndex].status ? RELAY_ACTIVE_STATE : RELAY_INACTIVE_STATE);
    Serial.printf("Relay '%s' di pin %d diubah menjadi %s\n", relays[relayIndex].deviceId, relays[relayIndex].pin, relays[relayIndex].status ? "ON" : "OFF");
    publishDeviceStatus(relays[relayIndex].deviceId, relays[relayIndex].status);
  }
}

void bukaPintu() {
  Serial.println("AKSES DITERIMA: Membuka kunci...");
  tone(BUZZER_PIN, 2000, 300);
  
  digitalWrite(RELAY_DOOR_PIN, RELAY_ACTIVE_STATE);
  publishDeviceStatus(DOOR_DEVICE_ID, true);
  
  delay(doorOpenDuration);
  
  digitalWrite(RELAY_DOOR_PIN, RELAY_INACTIVE_STATE);
  Serial.println("Kunci terkunci kembali.");
  publishDeviceStatus(DOOR_DEVICE_ID, false);
}

void tolakAkses() {
  Serial.println("AKSES DITOLAK");
  for (int i = 0; i < 3; i++) { tone(BUZZER_PIN, 100, 150); delay(200); }
}

bool authenticateRfidViaApi(String uid) {
  // ... (Fungsi ini dari kode Anda sudah cukup baik) ...
  // Pastikan Anda menggunakan wifiHttp di http.begin()
  // if (http.begin(wifiHttp, serverPath)) { ... }
}

void kirimLogScanMQTT(const char* uid, const char* statusBackend) {
  // ... (Fungsi ini dari kode Anda sudah cukup baik) ...
  // Ganti TOPIC_RFID_LOG_PUBLISH dengan topik yang benar jika berbeda
}

// --- FUNGSI LOOP UTAMA ---
void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    setup_wifi(); return;
  }
  if (!mqttClient.connected()) {
    reconnect_mqtt();
  }
  mqttClient.loop(); // Sangat penting untuk memproses pesan MQTT masuk

  // Cek kesehatan modul RFID secara berkala
  if (millis() - lastSelfTestTime > selfTestInterval) {
    lastSelfTestTime = millis();
    if (!mfrc522.PCD_PerformSelfTest()) {
      Serial.println("WARNING: RFID module self-test failed. Re-initializing...");
      mfrc522.PCD_Init();
    } else {
      Serial.println("RFID module self-test OK.");
    }
  }

  // Coba baca kartu baru
  if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()) {
    String uidString = "";
    for (byte i = 0; i < mfrc522.uid.size; i++) {
      uidString.concat(String(mfrc522.uid.uidByte[i] < 0x10 ? "0" : ""));
      uidString.concat(String(mfrc522.uid.uidByte[i], HEX));
    }
    uidString.toUpperCase();
    Serial.print("Card UID: "); Serial.println(uidString);

    if (authenticateRfidViaApi(uidString)) {
      bukaPintu();
      kirimLogScanMQTT(uidString.c_str(), "granted");
    } else {
      tolakAkses();
      kirimLogScanMQTT(uidString.c_str(), "denied");
    }

    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();
    
    delay(2000);
    Serial.println("\nSiap untuk kartu berikutnya...");
  }
}